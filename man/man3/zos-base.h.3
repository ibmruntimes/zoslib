.TH "include/zos-base.h" 3 "zoslib" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/zos-base.h
.SH SYNOPSIS
.br
.PP
\fC#include <_Nascii\&.h>\fP
.br
\fC#include <stdarg\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <sys/__getipc\&.h>\fP
.br
\fC#include <sys/ipc\&.h>\fP
.br
\fC#include <sys/shm\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <sys/socket\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include 'zos\-macros\&.h'\fP
.br
\fC#include 'zos\-bpx\&.h'\fP
.br
\fC#include 'zos\-char\-util\&.h'\fP
.br
\fC#include 'zos\-io\&.h'\fP
.br
\fC#include 'zos\-savstack\&.h'\fP
.br
\fC#include 'zos\-sys\-info\&.h'\fP
.br
\fC#include 'zos\-tls\&.h'\fP
.br
\fC#include 'zos\-getentropy\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fB__stack_info\fP"
.br
.ti -1c
.RI "struct \fB__cpu_relax_workarea\fP"
.br
.ti -1c
.RI "struct \fBzoslib_config\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB__ZOS_EXT__\fP   1"
.br
.ti -1c
.RI "#define \fB__ZOS_CC\fP"
.br
.ti -1c
.RI "#define \fBIPC_CLEANUP_ENVAR_DEFAULT\fP   '__IPC_CLEANUP'"
.br
.ti -1c
.RI "#define \fBRUNTIME_LIMIT_ENVAR_DEFAULT\fP   '__RUNTIMELIMIT'"
.br
.ti -1c
.RI "#define \fBCCSID_GUESS_BUF_SIZE_DEFAULT\fP   '__CCSIDGUESSBUFSIZE'"
.br
.ti -1c
.RI "#define \fBUNTAGGED_READ_MODE_DEFAULT\fP   '__UNTAGGED_READ_MODE'"
.br
.ti -1c
.RI "#define \fBUNTAGGED_READ_MODE_CCSID1047_DEFAULT\fP   '__UNTAGGED_READ_MODE_CCSID1047'"
.br
.ti -1c
.RI "#define \fBMEMORY_USAGE_LOG_FILE_ENVAR_DEFAULT\fP   '__MEMORY_USAGE_LOG_FILE'"
.br
.ti -1c
.RI "#define \fBMEMORY_USAGE_LOG_LEVEL_ENVAR_DEFAULT\fP   '__MEMORY_USAGE_LOG_LEVEL'"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fB__stack_info\fP \fB__stack_info\fP"
.br
.ti -1c
.RI "typedef struct \fB__cpu_relax_workarea\fP \fB__crwa_t\fP"
.br
.ti -1c
.RI "typedef struct \fB__Z_EXPORT\fP \fBzoslib_config\fP \fBzoslib_config_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBnotagread_t\fP { \fB__NO_TAG_READ_DEFAULT\fP = 0, \fB__NO_TAG_READ_DEFAULT_WITHWARNING\fP = 1, \fB__NO_TAG_READ_V6\fP = 2, \fB__NO_TAG_READ_STRICT\fP = 3 }"
.br
.ti -1c
.RI "enum \fBCOND_TIME_WAIT_CONSTANTS\fP { \fBCW_INTRPT\fP = 1, \fBCW_CONDVAR\fP = 32 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fB__Z_EXPORT\fP char ** \fB__get_environ_np\fP (void)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void \fB__xfer_env\fP (void)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void \fB__cleanupipc\fP (int others)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP const char * \fBgetIFAUsageErrorString\fP (unsigned long rc)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP unsigned long long \fB__registerProduct\fP (const char *major_version, const char *product_owner, const char *feature_name, const char *product_name, const char *pid)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fBgettid\fP ()"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__getMainThreadId\fP ()"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP pthread_t \fB__getMainThreadSelf\fP ()"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void \fB__display_backtrace\fP (int fd)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void \fB__set_backtrace_on_abort\fP (bool flag)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fBbacktrace\fP (void **buffer, int size)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP char ** \fBbacktrace_symbols\fP (void *const *buffer, int size)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void \fBbacktrace_symbols_fd\fP (void *const *buffer, int size, int fd)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void \fB__abend\fP (int comp_code, unsigned reason_code, int flat_byte, void *plist)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fBstrncasecmp_ignorecp\fP (const char *a, const char *b, size_t n)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fBstrcasecmp_ignorecp\fP (const char *a, const char *b)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__getargcv\fP (int *argc, char ***argv, pid_t pid)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__getexepath\fP (char *path, int pathlen, pid_t pid)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP char ** \fB__getargv\fP (void)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__getargc\fP (void)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int * \fB__get_stack_start\fP ()"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void * \fB__iterate_stack_and_get\fP (void *dsaptr, \fB__stack_info\fP *si)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void * \fB__dlcb_next\fP (void *last)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__dlcb_entry_name\fP (char *buf, int size, void *dlcb)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void * \fB__dlcb_entry_addr\fP (void *dlcb)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__dlcb_iterate\fP (int(*cb)(char *name, void *addr, void *data), void *data)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP unsigned long \fB__mach_absolute_time\fP (void)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void * \fB__zalloc\fP (size_t len, size_t alignment)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void * \fBanon_mmap\fP (void *_, size_t len)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void * \fB__zalloc_for_fd\fP (size_t len, const char *filename, int fd, off_t offset)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void * \fBroanon_mmap\fP (void *_, size_t len, int prot, int flags, const char *filename, int fd, off_t offset)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__zfree\fP (void *addr, int len)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fBanon_munmap\fP (void *addr, size_t len)"
.br
.ti -1c
.RI "int \fB__check_le_func\fP (void *addr, char *funcname, size_t len)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__cond_timed_wait\fP (unsigned int secs, unsigned int nsecs, unsigned int event_list, unsigned int *secs_rem, unsigned int *nsecs_rem)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__getentropy\fP (void *buffer, size_t length)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP char * \fB__get_le_version\fP (void)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void \fB__build_version\fP (void)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void \fB__tcp_clear_to_close\fP (int socket, unsigned int secs)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fBget_ipcs_overview\fP (IPCQPROC *info)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__print_zoslib_help\fP (\fBFILE\fP *fp, const char *title)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void \fB__cpu_relax\fP (\fB__crwa_t\fP *)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__testread\fP (const void *location)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void \fB__tb\fP (void)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP \fBnotagread_t\fP \fB__get_no_tag_read_behaviour\fP ()"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__get_no_tag_ignore_ccsid1047\fP ()"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void \fBinit_zoslib\fP (const \fBzoslib_config_t\fP config)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void \fBinit_zoslib_config\fP (\fBzoslib_config_t\fP *const config)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__update_envar_settings\fP (const char *envar)"
.br
.ti -1c
.RI "unsigned long \fB__get_libvec_base\fP (void)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP int \fB__update_envar_names\fP (\fBzoslib_config_t\fP *const config)"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP bool \fB__doLogMemoryUsage\fP ()"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP char * \fB__getMemoryUsageLogFile\fP ()"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP bool \fB__doLogMemoryAll\fP ()"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP bool \fB__doLogMemoryWarning\fP ()"
.br
.ti -1c
.RI "\fB__Z_EXPORT\fP void \fB__mainTerminating\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const char * \fB__zoslib_version\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define __ZOS_CC"

.SS "#define __ZOS_EXT__   1"

.SS "#define CCSID_GUESS_BUF_SIZE_DEFAULT   '__CCSIDGUESSBUFSIZE'"

.SS "#define IPC_CLEANUP_ENVAR_DEFAULT   '__IPC_CLEANUP'"

.SS "#define MEMORY_USAGE_LOG_FILE_ENVAR_DEFAULT   '__MEMORY_USAGE_LOG_FILE'"

.SS "#define MEMORY_USAGE_LOG_LEVEL_ENVAR_DEFAULT   '__MEMORY_USAGE_LOG_LEVEL'"

.SS "#define RUNTIME_LIMIT_ENVAR_DEFAULT   '__RUNTIMELIMIT'"

.SS "#define UNTAGGED_READ_MODE_CCSID1047_DEFAULT   '__UNTAGGED_READ_MODE_CCSID1047'"

.SS "#define UNTAGGED_READ_MODE_DEFAULT   '__UNTAGGED_READ_MODE'"

.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fB__cpu_relax_workarea\fP \fB__crwa_t\fP"

.SS "typedef struct \fB__stack_info\fP \fB__stack_info\fP"

.SS "typedef struct \fB__Z_EXPORT\fP \fBzoslib_config\fP \fBzoslib_config_t\fP"
Configuration for zoslib library 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBCOND_TIME_WAIT_CONSTANTS\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICW_INTRPT \fP\fP
.TP
\fB\fICW_CONDVAR \fP\fP
.SS "enum \fBnotagread_t\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fI__NO_TAG_READ_DEFAULT \fP\fP
.TP
\fB\fI__NO_TAG_READ_DEFAULT_WITHWARNING \fP\fP
.TP
\fB\fI__NO_TAG_READ_V6 \fP\fP
.TP
\fB\fI__NO_TAG_READ_STRICT \fP\fP
.SH "Function Documentation"
.PP 
.SS "\fB__Z_EXPORT\fP void __abend (int comp_code, unsigned reason_code, int flat_byte, void * plist)"
Generates an SVC 13 abend\&. 
.PP
\fBParameters\fP
.RS 4
\fIcomp_code\fP Completion code\&. 
.br
\fIreason_code\fP Reason code\&. 
.br
\fIflat_byte\fP Flat Byte\&. 
.br
\fIplist\fP Parameter list\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void __build_version (void)"
Prints the build version of the library 
.SS "int __check_le_func (void * addr, char * funcname, size_t len)"
Check if an LE function is present in the LE vector table 
.PP
\fBParameters\fP
.RS 4
\fIaddr\fP address to LE function 
.br
\fIfuncname\fP pointer to string that will hold the function name 
.br
\fImax\fP length of string corresponding to funcname 
.RE
.PP
\fBReturns\fP
.RS 4
returns 1 if successful, 0 if unsuccessful\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void __cleanupipc (int others)"
Remove IPC semaphores and shared memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIothers\fP non-zero value indicates remove IPC not associated with current process\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int __cond_timed_wait (unsigned int secs, unsigned int nsecs, unsigned int event_list, unsigned int * secs_rem, unsigned int * nsecs_rem)"
Suspend the calling thread until any one of a set of events has occurred or until a specified amount of time has passed\&. 
.PP
\fBParameters\fP
.RS 4
\fIsecs\fP seconds to suspend 
.br
\fInsecs\fP nanoseconds to suspend 
.br
\fIevent_list\fP events that will trigger thread to resume (CW_INTRPT or CW_CONDVAR) 
.br
\fIsecs_rem\fP seconds remaining 
.br
\fInsecs_rem\fP nanoseconds remaining 
.RE
.PP
\fBReturns\fP
.RS 4
returns 0 if successful, -1 if unsuccessful\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void __cpu_relax (\fB__crwa_t\fP * p)"
TODO(itodorov) - zos: document these interfaces 
.SS "\fB__Z_EXPORT\fP void __display_backtrace (int fd)"
Print backtrace of stack to file descriptor\&. 
.PP
\fBParameters\fP
.RS 4
\fIfd\fP file descriptor\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void * __dlcb_entry_addr (void * dlcb)"
Get address of dlcb entry 
.PP
\fBParameters\fP
.RS 4
\fIdlcb\fP - current dlcb 
.RE
.PP
\fBReturns\fP
.RS 4
returns entry address of dlcb 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int __dlcb_entry_name (char * buf, int size, void * dlcb)"
Get entry name of given dlcb 
.PP
\fBParameters\fP
.RS 4
\fIbuf\fP - DLL name of given dlcb 
.br
\fIsize\fP - maximum number of bytes 
.br
\fIdlcb\fP - current dlcb 
.RE
.PP
\fBReturns\fP
.RS 4
[in] number of bytes written to buf 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int __dlcb_iterate (int(*)(char *name, void *addr, void *data) cb, void * data)"
Walk through list of dlcb 
.PP
\fBParameters\fP
.RS 4
\fIcb\fP - callback function for each dlcb, the callback will have the name, the address and data, which is a copy of whatever value was passed as the second argument, as input parameters 
.br
\fIdata\fP - pass to callback 
.RE
.PP
\fBReturns\fP
.RS 4
returns whatever value was returned by the last call to callback, if no dlcb is found, return -1 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void * __dlcb_next (void * last)"
Get next dlcb entry 
.PP
\fBParameters\fP
.RS 4
\fIlast\fP - previous dlcb entry 
.RE
.PP
\fBReturns\fP
.RS 4
[in] returns next dlcb entry 
.RE
.PP

.SS "\fB__Z_EXPORT\fP bool __doLogMemoryAll ()"
Returns true if all messages from memory allocation and release are being displayed\&. 
.SS "\fB__Z_EXPORT\fP bool __doLogMemoryUsage ()"
Returns true if logging of memory allocation and release is specified\&. 
.SS "\fB__Z_EXPORT\fP bool __doLogMemoryWarning ()"
Returns true if only warnings from memory allocation and release are being displayed\&. Errors are always included if memory logging in on\&. 
.SS "\fB__Z_EXPORT\fP char ** __get_environ_np (void)"
Get the environ\&. 
.PP
\fBReturns\fP
.RS 4
returns pointer to environment list 
.RE
.PP

.SS "\fB__Z_EXPORT\fP char * __get_le_version (void)"
Return the LE version as a string in the format of 'Product %d%s Version %d Release %d Modification %d' 
.SS "unsigned long __get_libvec_base (void)"
Gets the LE libvec base address 
.PP
\fBReturns\fP
.RS 4
libvec base address 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int __get_no_tag_ignore_ccsid1047 ()"

.SS "\fB__Z_EXPORT\fP \fBnotagread_t\fP __get_no_tag_read_behaviour ()"

.SS "\fB__Z_EXPORT\fP int * __get_stack_start ()"
Get the stack start address for the current thread 
.PP
\fBReturns\fP
.RS 4
returns the stack start address 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int __getargc (void)"
Get program argument count of the current process 
.PP
\fBReturns\fP
.RS 4
returns count of process arguments 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int __getargcv (int * argc, char *** argv, pid_t pid)"
Get program argument list of a given process id 
.PP
\fBParameters\fP
.RS 4
\fIargc\fP - pointer to store count of the arguments 
.br
\fIargv\fP - pointer to store an array of pointers that point to each argument 
.br
\fIpid\fP - process id to obtain the argc and argv for 
.RE
.PP
\fBNote\fP
.RS 4
Call free(argv) when done accessing argv\&. 
.RE
.PP
\fBReturns\fP
.RS 4
On success, returns 0, or -1 on error\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP char ** __getargv (void)"
Get program argument list of the current process 
.PP
\fBReturns\fP
.RS 4
returns an array of process arguments 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int __getentropy (void * buffer, size_t length)"
Fill a buffer with random bytes 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP to store random bytes to\&. 
.br
\fInumber\fP of random bytes to generate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
On success, returns 0, or -1 on error\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int __getexepath (char * path, int pathlen, pid_t pid)"
Get the executable path of a given process id 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP - pointer to the destination array to copy the null-terminated path to 
.br
\fIpathlen\fP - length of the given array 
.br
\fIpid\fP - process id to obtain the executable path for 
.RE
.PP
\fBReturns\fP
.RS 4
On success, returns 0, or -1 on error\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int __getMainThreadId ()"
Get the main Thread ID\&. If a process is started with sh -c, main thread id is 0; if started with bash -c, main thread id is 2; if started directly from the shell, main thread id is 1\&. 
.PP
\fBReturns\fP
.RS 4
returns the current thread id 
.RE
.PP

.SS "\fB__Z_EXPORT\fP pthread_t __getMainThreadSelf ()"
Get the pthread_self() for the main thread\&. 
.PP
\fBReturns\fP
.RS 4
returns the current pthread_self() for main thread 
.RE
.PP

.SS "\fB__Z_EXPORT\fP char * __getMemoryUsageLogFile ()"
Returns the file name, including 'stdout' or 'stderr', used to log memory allocation and release to\&. 
.SS "\fB__Z_EXPORT\fP void * __iterate_stack_and_get (void * dsaptr, \fB__stack_info\fP * si)"
Iterate to next stack dsa based on current dsa 
.PP
\fBParameters\fP
.RS 4
\fIdsaptr\fP - current dsa entry 
.br
\fIsi\fP - stack information of next dsa 
.RE
.PP
\fBReturns\fP
.RS 4
returns the next dsa entry in the chain or 0 if not found 
.RE
.PP

.SS "\fB__Z_EXPORT\fP unsigned long __mach_absolute_time (void)"
Obtain the mach absolute time 
.PP
\fBReturns\fP
.RS 4
returns mach absolute time 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void __mainTerminating ()"
Tell zoslib that the main process is terminating, for its diagnostics\&. 
.SS "\fB__Z_EXPORT\fP int __print_zoslib_help (\fBFILE\fP * fp, const char * title)"
Prints zoslib help information to specified FILE pointer 
.PP
\fBParameters\fP
.RS 4
\fIFILE\fP pointer to write to 
.br
\fItitle\fP header, specify NULL for default 
.RE
.PP
\fBReturns\fP
.RS 4
On success, returns 0, or < 0 on error\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP unsigned long long __registerProduct (const char * major_version, const char * product_owner, const char * feature_name, const char * product_name, const char * pid)"
Registers product for SMF 89 Type 1 records using IFAUSAGE macro\&. 
.PP
\fBParameters\fP
.RS 4
\fImajor_version\fP The major version of Product (e\&.g\&. 14) 
.br
\fIproduct_owner\fP The product owner (e\&.g\&. IBM) 
.br
\fIfeature_name\fP The feature name (e\&.g\&. Node\&.js) 
.br
\fIproduct_name\fP The product name (e\&.g\&. Node\&.js for z/OS) 
.br
\fIpid\fP The Product ID (e\&.g\&. 5676-SDK) 
.RE
.PP
\fBReturns\fP
.RS 4
returns 0 if successful, non-zero if unsuccessful\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void __set_backtrace_on_abort (bool flag)"
Enable or disable \fBabort()\fP from calling display_backtrace()\&. Default is true\&. 
.SS "\fB__Z_EXPORT\fP void __tb (void)"

.SS "\fB__Z_EXPORT\fP void __tcp_clear_to_close (int socket, unsigned int secs)"
Attempts to a close a socket for a period of time 
.PP
\fBParameters\fP
.RS 4
\fIsocket\fP socket handle 
.br
\fIsecs\fP number of seconds to attempt the close 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int __testread (const void * location)"
TODO(itodorov) - zos: document these interfaces 
.SS "\fB__Z_EXPORT\fP int __update_envar_names (\fBzoslib_config_t\fP *const config)"
Changes the names of one or more of the environment variables zoslib uses 
.PP
\fBParameters\fP
.RS 4
\fIzoslib_confit_t\fP structure that defines the new environment variable name(s) 
.RE
.PP
\fBReturns\fP
.RS 4
0 for success, or -1 for failure 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int __update_envar_settings (const char * envar)"
Updates the zoslib global variables associated with the zoslib environment variables
.PP
\fBParameters\fP
.RS 4
\fIenvar\fP environment variable to update, specify NULL to update all 
.RE
.PP
\fBReturns\fP
.RS 4
0 for success, or -1 for failure 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void __xfer_env (void)"
Convert environment variables from EBCDIC to ASCII\&. 
.SS "\fB__Z_EXPORT\fP void * __zalloc (size_t len, size_t alignment)"
Allocate memory in 64-bit virtual storage when size is a megabyte multiple or above 2GB, or in 31-bit storage otherwise, and if none is available, attempt to allocate from 64-bit virtual storage\&. 
.PP
\fBParameters\fP
.RS 4
\fIlen\fP length in bytes of memory to allocate 
.br
\fIalignment\fP in bytes and applies only to 31-bit storage (64-bit storage is always megabyte-aligned) 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the beginning of newly allocated memory, or 0 if unsuccessful 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void * __zalloc_for_fd (size_t len, const char * filename, int fd, off_t offset)"
Allocate memory (using \fB__zalloc()\fP) and read into it contents of given file 
.PP
\fBParameters\fP
.RS 4
\fIlen\fP length in bytes of memory to allocate 
.br
\fIfilename\fP filename to read 
.br
\fIfd\fP file descriptor 
.br
\fIoffset\fP offset in bytes into the file to read 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the beginning of newly allocated memory, or 0 if unsuccessful 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int __zfree (void * addr, int len)"
Deallocate memory 
.PP
\fBParameters\fP
.RS 4
\fIaddr\fP start address of memory 
.br
\fIlen\fP length in bytes 
.RE
.PP
\fBReturns\fP
.RS 4
returns 0 if successful, -1 if unsuccessful 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void * anon_mmap (void * _, size_t len)"
Allocate memory in 64-bit virtual storage when size is a megabyte multiple or above 2GB, or in 31-bit storage (with PAGE_SIZE bytes alignment) otherwise, and if none is available, attempt to allocate from 64-bit virtual storage\&. 
.PP
\fBParameters\fP
.RS 4
\fI_\fP ignored 
.br
\fIlen\fP length in bytes of memory to allocate 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the beginning of newly allocated memory, or MAP_FAILED if unsuccessful 
.RE
.PP
\fBDeprecated\fP
.RS 4
This function will be removed once mmap is fully functional (e\&.g\&. MAP_ANONYMOUS is supported) 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int anon_munmap (void * addr, size_t len)"
Deallocate memory 
.PP
\fBParameters\fP
.RS 4
\fIaddr\fP start address of memory 
.br
\fIlen\fP length in bytes 
.RE
.PP
\fBReturns\fP
.RS 4
returns 0 if successful, -1 if unsuccessful 
.RE
.PP
\fBDeprecated\fP
.RS 4
This function will be removed once mmap is fully functional (e\&.g\&. MAP_ANONYMOUS is supported) 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int backtrace (void ** buffer, int size)"
Generate a backtrace and store into *Buffer\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP Address of location to store backtrace to\&. 
.br
\fIsize\fP Maximum number of bytes to store\&. 
.RE
.PP
\fBReturns\fP
.RS 4
if successful, returns 0, otherwise -1 
.RE
.PP

.SS "\fB__Z_EXPORT\fP char ** backtrace_symbols (void *const * buffer, int size)"
Generate a backtrace symbols and store into *Buffer\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP Address of location to store backtrace to\&. 
.br
\fIsize\fP Maximum number of bytes to store\&. 
.RE
.PP
\fBReturns\fP
.RS 4
if successful, an array of strings, otherwise returns NULL\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void backtrace_symbols_fd (void *const * buffer, int size, int fd)"
Generate a backtrace symbols and store into *Buffer\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP Address of location to store backtrace to\&. 
.br
\fIsize\fP Maximum number of bytes to store\&. 
.br
\fIfd\fP file descriptor\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int get_ipcs_overview (IPCQPROC * info)"
Returns the overview structure of IPCQPROC 
.PP
\fBParameters\fP
.RS 4
\fIinfo\fP address of allocated IPCQPROC structure 
.RE
.PP
\fBReturns\fP
.RS 4
On success, returns 0, or -1 on error\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP const char * getIFAUsageErrorString (unsigned long rc)"
Retrieves error message from __registerProduct IFAUSAGE macro\&. 
.PP
\fBParameters\fP
.RS 4
\fIrc\fP return code from __registerProduct\&. 
.RE
.PP
\fBReturns\fP
.RS 4
returns error message as C character string\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int gettid ()"
Get the Thread ID\&. 
.PP
\fBReturns\fP
.RS 4
returns the current thread id 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void init_zoslib (const \fBzoslib_config_t\fP config)"
Initialize zoslib library 
.PP
\fBParameters\fP
.RS 4
\fIconfig\fP struct to configure zoslib\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void init_zoslib_config (\fBzoslib_config_t\fP *const config)"
Initialize the struct used to configure zoslib with default values\&. 
.PP
\fBParameters\fP
.RS 4
\fIconfig\fP struct to configure zoslib\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP void * roanon_mmap (void * _, size_t len, int prot, int flags, const char * filename, int fd, off_t offset)"
Allocate memory (using \fB__zalloc()\fP) and read into it contents of given file at the given offset\&. 
.PP
\fBParameters\fP
.RS 4
\fI_\fP ignored 
.br
\fIlen\fP length in bytes of memory map 
.br
\fIprot\fP protection bits 
.br
\fIflags\fP mmap flags 
.br
\fIfilename\fP filename to read 
.br
\fIfd\fP file descriptor 
.br
\fIoffset\fP offset in bytes into the file to read 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the beginning of newly allocated memory, or MAP_FAILED if unsuccessful 
.RE
.PP
\fBDeprecated\fP
.RS 4
This function will be removed once mmap is fully functional (e\&.g\&. MAP_ANONYMOUS is supported), in which case mapped memory would need to be converted to ASCII if the file contains EBCDIC\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int strcasecmp_ignorecp (const char * a, const char * b)"
String case comparision that ignores code page\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP - null-terminated character string\&. 
.br
\fIb\fP - null-terminated character string\&. 
.RE
.PP
\fBReturns\fP
.RS 4
if equal, returns 0, otherwise returns non-zero\&. 
.RE
.PP

.SS "\fB__Z_EXPORT\fP int strncasecmp_ignorecp (const char * a, const char * b, size_t n)"
String case comparision that ignores code page\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP - Character String\&. 
.br
\fIb\fP - Character String\&. 
.br
\fIn\fP - Number of bytes to compare\&. 
.RE
.PP
\fBReturns\fP
.RS 4
if equal, returns 0, otherwise returns non-zero\&. 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "const char* __zoslib_version\fC [extern]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for zoslib from the source code\&.
